// ----------------------------------------------------------------------------
// SystemC Testbench Header
//
//    HLS version: 10.0a/269363 Production Release
//       HLS date: Wed Nov  9 17:38:00 PST 2016
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 8.0a
//
//   Generated by: xph3sle509@ocaepc57
// Generated date: Tue Jan 16 14:33:17 CET 2018
//
// ----------------------------------------------------------------------------
#ifdef CCS_SCVERIFY

// 
// -------------------------------------
// testbench
// User supplied testbench
// -------------------------------------
// 
#ifndef INCLUDED_TESTBENCH_H
#define INCLUDED_TESTBENCH_H

extern void mc_testbench_mask_skip(bool v);
extern void mc_testbench_filtre_skip(bool v);
extern void mc_testbench_image_net_skip(bool v);
extern void mc_testbench_image_floue_skip(bool v);
extern void mc_testbench_image_error_skip(bool v);
extern void mc_testbench_depth_skip(bool v);
extern void mc_testbench_return_skip(bool v);

#ifndef SC_USE_STD_STRING
#define SC_USE_STD_STRING
#endif

#include <systemc.h>
#include <tlm.h>
#include <mc_container_types.h>
#include <mc_typeconv.h>
#include <mc_transactors.h>
#include <mc_comparator.h>
#include <mc_end_of_testbench.h>
#include <vector>


class testbench : public sc_module
{
public:
   // Interface Ports
   sc_in< bool > clk;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<int,68256> > > ccs_mask;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_mask;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<double,289> > > ccs_filtre;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_filtre;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<int,60000> > > ccs_image_net;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_image_net;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<int,60000> > > ccs_image_floue;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_image_floue;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<int,68256> > > ccs_image_error_IN;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_image_error_IN;
   sc_port< tlm::tlm_fifo_get_if< mgc_sysc_ver_array1D<int,68256> > > ccs_image_error;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_image_error;
   sc_port< tlm::tlm_fifo_get_if< mgc_sysc_ver_array1D<int,60000> > > ccs_depth;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_depth;
   sc_port< tlm::tlm_fifo_get_if< int > > ccs_return;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_return;
   sc_in< bool > design_is_idle;
   sc_out< sc_logic > enable_stalls;
   sc_in< unsigned short > stall_coverage;
   
   // Data objects
   bool testbench_ended;
   int main_exit_code;
   bool atleast_one_active_input;
   sc_time last_event_time;
   sc_time last_event_time2;
   sc_signal< bool >                          cpp_testbench_active;
   sc_event testbench_end_event;
   int argc;
   const char* const *argv;
   bool _checked_results;
   bool _failed;
   static testbench* that;
   static std::vector<mc_end_of_testbench*> _end_of_tb_objs;
   int main();
   static bool mask_ignore;
   static bool mask_skip;
   static bool mask_skip_quiet;
   static bool mask_skip_once;
   static bool mask_skip_noerr;
   static int mask_array_comp_first;
   static int mask_array_comp_last;
   bool _capture_mask;
   static int mask_wait_cycles;
   static mc_wait_ctrl mask_wait_ctrl;
   int mask_capture_count;
   int mask_iteration_count;
   static bool filtre_ignore;
   static bool filtre_skip;
   static bool filtre_skip_quiet;
   static bool filtre_skip_once;
   static bool filtre_skip_noerr;
   static int filtre_array_comp_first;
   static int filtre_array_comp_last;
   bool _capture_filtre;
   static int filtre_wait_cycles;
   static mc_wait_ctrl filtre_wait_ctrl;
   int filtre_capture_count;
   int filtre_iteration_count;
   static bool image_net_ignore;
   static bool image_net_skip;
   static bool image_net_skip_quiet;
   static bool image_net_skip_once;
   static bool image_net_skip_noerr;
   static int image_net_array_comp_first;
   static int image_net_array_comp_last;
   bool _capture_image_net;
   static int image_net_wait_cycles;
   static mc_wait_ctrl image_net_wait_ctrl;
   int image_net_capture_count;
   int image_net_iteration_count;
   static bool image_floue_ignore;
   static bool image_floue_skip;
   static bool image_floue_skip_quiet;
   static bool image_floue_skip_once;
   static bool image_floue_skip_noerr;
   static int image_floue_array_comp_first;
   static int image_floue_array_comp_last;
   bool _capture_image_floue;
   static int image_floue_wait_cycles;
   static mc_wait_ctrl image_floue_wait_ctrl;
   int image_floue_capture_count;
   int image_floue_iteration_count;
   static bool image_error_ignore;
   static bool image_error_skip;
   static bool image_error_skip_quiet;
   static bool image_error_skip_once;
   static bool image_error_skip_noerr;
   static int image_error_array_comp_first;
   static int image_error_array_comp_last;
   bool _capture_image_error_IN;
   static int image_error_IN_wait_cycles;
   static mc_wait_ctrl image_error_IN_wait_ctrl;
   int image_error_IN_capture_count;
   int image_error_IN_iteration_count;
   static bool image_error_use_mask;
   static int image_error_output_mask;
   tlm::tlm_fifo< mc_golden_info< mgc_sysc_ver_array1D<int,68256>, int > > image_error_golden;
   bool _capture_image_error;
   static int image_error_wait_cycles;
   static mc_wait_ctrl image_error_wait_ctrl;
   int image_error_capture_count;
   int image_error_iteration_count;
   static bool depth_ignore;
   static bool depth_skip;
   static bool depth_skip_quiet;
   static bool depth_skip_once;
   static bool depth_skip_noerr;
   static int depth_array_comp_first;
   static int depth_array_comp_last;
   static bool depth_use_mask;
   static int depth_output_mask;
   tlm::tlm_fifo< mc_golden_info< mgc_sysc_ver_array1D<int,60000>, int > > depth_golden;
   bool _capture_depth;
   static int depth_wait_cycles;
   static mc_wait_ctrl depth_wait_ctrl;
   int depth_capture_count;
   int depth_iteration_count;
   static bool return_ignore;
   static bool return_skip;
   static bool return_skip_quiet;
   static bool return_skip_once;
   static bool return_skip_noerr;
   static int return_array_comp_first;
   static int return_array_comp_last;
   static bool return_use_mask;
   static int return_output_mask;
   tlm::tlm_fifo< mc_golden_info< int, int > > return_golden;
   bool _capture_return;
   static int return_wait_cycles;
   static mc_wait_ctrl return_wait_ctrl;
   int return_capture_count;
   int return_iteration_count;
   int wait_cnt;
   
   // Named Objects
   
   // Module instance pointers
   mc_comparator< mgc_sysc_ver_array1D<int,68256> , int > *image_error_comp;
   mc_comparator< mgc_sysc_ver_array1D<int,60000> , int > *depth_comp;
   mc_comparator< int , int > *return_comp;
   
   // Declare processes (SC_METHOD and SC_THREAD)
   void wait_for_end();
   void run();
   
   // Constructor
   SC_HAS_PROCESS(testbench);
   testbench(
      const sc_module_name& name
   )
      : clk("clk")
      , ccs_mask("ccs_mask")
      , ccs_wait_ctrl_mask("ccs_wait_ctrl_mask")
      , ccs_filtre("ccs_filtre")
      , ccs_wait_ctrl_filtre("ccs_wait_ctrl_filtre")
      , ccs_image_net("ccs_image_net")
      , ccs_wait_ctrl_image_net("ccs_wait_ctrl_image_net")
      , ccs_image_floue("ccs_image_floue")
      , ccs_wait_ctrl_image_floue("ccs_wait_ctrl_image_floue")
      , ccs_image_error_IN("ccs_image_error_IN")
      , ccs_wait_ctrl_image_error_IN("ccs_wait_ctrl_image_error_IN")
      , ccs_image_error("ccs_image_error")
      , ccs_wait_ctrl_image_error("ccs_wait_ctrl_image_error")
      , ccs_depth("ccs_depth")
      , ccs_wait_ctrl_depth("ccs_wait_ctrl_depth")
      , ccs_return("ccs_return")
      , ccs_wait_ctrl_return("ccs_wait_ctrl_return")
      , design_is_idle("design_is_idle")
      , enable_stalls("enable_stalls")
      , stall_coverage("stall_coverage")
      , cpp_testbench_active("cpp_testbench_active")
      , image_error_golden("image_error_golden",-1)
      , depth_golden("depth_golden",-1)
      , return_golden("return_golden",-1)
   {
      // Instantiate other modules
      image_error_comp = new mc_comparator< mgc_sysc_ver_array1D<int,68256> , int > (
         "image_error_comp",
         0,
         1
      );
      image_error_comp->data_in(ccs_image_error);
      image_error_comp->data_golden(image_error_golden);
      
      depth_comp = new mc_comparator< mgc_sysc_ver_array1D<int,60000> , int > (
         "depth_comp",
         0,
         1
      );
      depth_comp->data_in(ccs_depth);
      depth_comp->data_golden(depth_golden);
      
      return_comp = new mc_comparator< int , int > (
         "return_comp",
         0,
         1
      );
      return_comp->data_in(ccs_return);
      return_comp->data_golden(return_golden);
      
      
      // Register processes
      SC_METHOD(wait_for_end);
      sensitive << clk.pos() << testbench_end_event;
      SC_THREAD(run);
      // Other constructor statements
      set_stack_size(64000000);
      argc = sc_argc();
      argv = sc_argv();
      _checked_results = false;
      that = this;
      testbench_ended = false;
      main_exit_code = 0;
      atleast_one_active_input = true;
      _capture_mask = true;
      _capture_filtre = true;
      _capture_image_net = true;
      _capture_image_floue = true;
      _capture_image_error_IN = true;
      _capture_image_error = true;
      _capture_depth = true;
      _capture_return = true;
      wait_cnt = 0;
   }
   
   ~testbench()
   {
      delete image_error_comp;
      image_error_comp = 0;
      delete depth_comp;
      depth_comp = 0;
      delete return_comp;
      return_comp = 0;
   }
   
   // C++ class functions
   public:
      static void wait_for_idle_sync() ;
   public:
      static void set_enable_stalls(bool flag) ;
   public:
      static void register_end_of_testbench_obj(mc_end_of_testbench* obj) ;
   public:
      void capture_mask( int mask[316][216]) ;
   public:
      void capture_filtre( double filtre[17][17]) ;
   public:
      void capture_image_net( int image_net[300][200]) ;
   public:
      void capture_image_floue( int image_floue[300][200]) ;
   public:
      void capture_image_error_IN( int image_error[316][216]) ;
   public:
      void capture_image_error( int image_error[316][216]) ;
   public:
      void capture_depth( int depth[300][200]) ;
   public:
      void capture__TOP__return(int _TOP__return) ;
   protected:
      void wait_on_input_required() ;
   public:
      static void capture_IN( int mask[316][216],  double filtre[17][17],  int image_net[300][200],  int image_floue[300][200],  int image_error[316][216],  int depth[300][200]) ;
   public:
      static void capture_OUT(int _TOP__return,  int mask[316][216],  double filtre[17][17],  int image_net[300][200],  int image_floue[300][200],  int image_error[316][216],  int depth[300][200]) ;
   public:
      static int exec_main( int mask[316][216],  double filtre[17][17],  int image_net[300][200],  int image_floue[300][200],  int image_error[316][216],  int depth[300][200]) ;
   protected:
      void start_of_simulation() ;
   protected:
      void end_of_simulation() ;
   public:
      void check_results() ;
   public:
      bool failed() ;
};
#endif
#endif
